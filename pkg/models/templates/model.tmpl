// Package models contains the database interaction model code
//
// GENERATED BY GOSCHEMA. DO NOT EDIT.
package {{ .OutputDir | base | snakecase }}

import (
	"database/sql"
	"errors"
	"time"

	"github.com/go-sql-driver/mysql"
	"github.com/Jacobbrewer1/patcher"
	"github.com/Jacobbrewer1/patcher/inserter"
	"github.com/Jacobbrewer1/goschema/pkg/usql"
	"github.com/prometheus/client_golang/prometheus"
)
{{ with .Table }}
{{ $struct := .Name | structify }}
// {{ $struct }} represents a row from '{{ .Name }}'.
{{- if .Comment }}
// {{ .Comment }}
{{- end }}
type {{ $struct }} struct {
	{{ range $column := .Columns -}}
	{{ .Name | structify }} {{ template "type" $column }} {{ template "tags" $column }} {{ if .Comment }}// {{ .Comment }}{{ end }}
	{{ end -}}
}

{{ template "insert" . }}

{{ if has_primary_key . -}}
// IsPrimaryKeySet returns true if all primary key fields are set to none zero values
func (m *{{ $struct }}) IsPrimaryKeySet() bool {
	{{ $length := len .PrimaryKey.Columns -}}
	{{ if eq $length 1 -}}
	{{ $column := index .PrimaryKey.Columns 0 -}}
	return IsKeySet(m.{{ $column.Name | structify }})
	{{ else -}}
	return {{ range $i, $column := .PrimaryKey.Columns -}}{{ if $i }} && {{ end }}IsKeySet(m.{{ $column.Name | structify }}){{ end }}
	{{ end -}}
}
{{- end }}

{{ if identity_columns . -}}
{{ if non_identity_columns . -}}
{{ template "update" . }}

{{ template "insert_update" . }}
{{- end }}
{{- end }}

// Save saves the {{ $struct }} to the database.
func (m *{{ $struct }}) Save(db DB) error {
	{{ if identity_columns . -}}
	{{ if non_identity_columns . -}}
	if m.IsPrimaryKeySet() {
		return m.Update(db)
	}
	{{ end -}}
	{{ end -}}
	return m.Insert(db)
}

{{ if identity_columns . -}}
{{ if non_identity_columns . -}}
// SaveOrUpdate saves the {{ $struct }} to the database, but tries to update
// on unique constraint violations.
func (m *{{ $struct }}) SaveOrUpdate(db DB) error {
	{{ if identity_columns . -}}
	{{ if non_identity_columns . -}}
	if m.IsPrimaryKeySet() {
		return m.Update(db)
	}
	{{ end -}}
	{{ end -}}
	return m.InsertWithUpdate(db)
}
{{- end }}
{{- end }}

{{ template "delete" .}}

{{ range $key := unique_column_keys . }}
{{ $key_cnt := len $key.Columns }}
{{ $tbl_cnt := len $.Table.Columns }}
{{ if ne $key_cnt $tbl_cnt }}
{{ if eq $key.Type "primary" -}}
// {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }} retrieves a row from '{{ $.Table.Name }}' as a {{ $struct }}.
//
// Generated from primary key.
func {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }}(db DB, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }} {{ template "type" $col}}{{ end }}) (*{{ $struct }}, error) {
    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("insert_{{ $struct | structify -}}"))
    defer t.ObserveDuration()

	const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }}, {{ end }}`{{ $column.Name }}`{{ end }} " +
		"FROM {{ $.Table.Name }} " +
		"WHERE {{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}"

	DBLog(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
	var m {{ $struct }}
	if err := db.Get(&m, sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }}); err != nil {
		return nil, err
	}

	return &m, nil
}
{{ range $constraint := $.Table.Constraints -}}
{{ $constraint_ref_len := len $constraint.References }}
{{ if eq $constraint_ref_len 1 -}}
{{ $foreign_struct := $constraint.ReferenceTable | structify }}
{{ range $i, $col_data := $.Table.Columns -}}
{{ range $local_col, $foreign_col := $constraint.References -}}
{{ if eq $col_data.Name $local_col -}}
// Get{{ $local_col | structify }}{{ $foreign_struct }} Gets an instance of {{ $foreign_struct }}
//
// Generated from constraint {{ $constraint.Name }}
func (m *{{ $struct }}) Get{{ $local_col | structify }}{{ $foreign_struct }}(db DB) (*{{ $foreign_struct }}, error) {
  {{ if $col_data.Nullable -}}
  if !m.{{ $local_col | structify }}.Valid {
    return nil, nil
  }

  {{ end -}}
	return {{ $foreign_struct }}By{{ $foreign_col | structify }}(db, m.{{ $local_col | structify }}{{ if $col_data.Nullable }}.{{ template "type_reverse_nullable" $col_data }}{{ end }})
}
{{ end -}}
{{ end -}}
{{ end -}}
{{- end }}
{{- end }}

{{- else -}}
{{- $uniq := contains "unique" $key.Type }}
{{- if $uniq }}
// {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }} retrieves {{ if $uniq }}a row{{ else }}rows{{ end }} from '{{ $.Table.Name }}' as a {{ if $uniq }}*{{ $struct }}{{ else }}[]*{{ $struct }}{{ end }}.
//
// Generated from index '{{ $key.Name }}' of type '{{ $key.Type }}'.
func {{ $struct }}By{{ range $i, $col := $key.Columns }}{{ $col.Name | structify }}{{ end }}(db DB, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }} {{ template "type" $col}}{{ end }}) ({{ if not $uniq }}[]{{ end }}*{{ $struct }}, error) {
    t := prometheus.NewTimer(DatabaseLatency.WithLabelValues("insert_{{ $struct | structify -}}"))
    defer t.ObserveDuration()

	const sqlstr = "SELECT {{ range $i, $column := $.Table.Columns }}{{ if $i }}, {{ end }}`{{ $column.Name }}`{{ end }} " +
		"FROM {{ $.Table.Name }} " +
		"WHERE {{ range $i, $col := $key.Columns }}{{ if $i }} AND {{ end }}`{{ $col.Name }}` = ?{{ end }}"

	DBLog(sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }})
	var m {{ if not $uniq }}[]*{{ end }}{{ $struct }}
	if err := db.{{ if $uniq }}Get{{ else }}Select{{ end }}(&m, sqlstr, {{ range $i, $col := $key.Columns }}{{ if $i }}, {{ end }}{{ $col.Name | structify | lcfirst }}{{ end }}); err != nil {
		return nil, err
	}

	return {{ if $uniq }}&{{ end }}m, nil
}
{{ end }}
{{ end }}
{{ end }}
{{ end }}

{{- range $enumcol := enum_columns . }}
// Valid values for the '{{ $enumcol.Name | structify }}' enum column
var (
{{- range $enum := .Elements }}
	{{ $struct }}{{ $enumcol.Name | structify }}{{ $enum | structify }} = {{ if $enumcol.Nullable }}msql.NewNullEnum("{{ $enum }}"){{ else }}"{{ $enum }}"{{ end }}
{{- end }}
{{- if $enumcol.Nullable }}
	{{ $struct }}{{ $enumcol.Name | structify }}Null = msql.NullEnum{}
{{- end }}
)
{{ end }}

{{ end }}
